Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    FOR
    STRING
    WHILE

Grammar

Rule 0     S' -> program
Rule 1     program -> fun_decl
Rule 2     fun_decl -> type ID LPAREN param_list RPAREN compound_stmt
Rule 3     param_list -> type ID
Rule 4     param_list -> param_list COMMA type ID
Rule 5     param_list -> VOID
Rule 6     type -> INT
Rule 7     type -> VOID
Rule 8     type -> CHAR
Rule 9     compound_stmt -> LBRACE stmt_list RBRACE
Rule 10    stmt_list -> stmt
Rule 11    stmt_list -> stmt stmt_list
Rule 12    stmt -> expr_stmt
Rule 13    stmt -> if_stmt
Rule 14    stmt -> return_stmt
Rule 15    stmt -> var_decl
Rule 16    expr_stmt -> expr SEMI
Rule 17    if_stmt -> IF LPAREN expr RPAREN compound_stmt
Rule 18    if_stmt -> IF LPAREN expr RPAREN compound_stmt ELSE compound_stmt
Rule 19    return_stmt -> RETURN expr SEMI
Rule 20    var_decl -> type ID SEMI
Rule 21    expr -> var ASSIGN expr
Rule 22    expr -> var
Rule 23    expr -> NUMBER
Rule 24    expr -> expr PLUS expr
Rule 25    expr -> expr MINUS expr
Rule 26    expr -> expr TIMES expr
Rule 27    expr -> expr DIVIDE expr
Rule 28    expr -> expr MODULO expr
Rule 29    expr -> expr LT expr
Rule 30    expr -> expr LE expr
Rule 31    expr -> expr GT expr
Rule 32    expr -> expr GE expr
Rule 33    expr -> expr EQ expr
Rule 34    expr -> expr NE expr
Rule 35    expr -> expr AND expr
Rule 36    expr -> expr OR expr
Rule 37    expr -> NOT expr
Rule 38    expr -> LPAREN expr RPAREN
Rule 39    var -> ID

Terminals, with rules where they appear

AND                  : 35
ASSIGN               : 21
CHAR                 : 8
COMMA                : 4
DIVIDE               : 27
ELSE                 : 18
EQ                   : 33
FOR                  : 
GE                   : 32
GT                   : 31
ID                   : 2 3 4 20 39
IF                   : 17 18
INT                  : 6
LBRACE               : 9
LE                   : 30
LPAREN               : 2 17 18 38
LT                   : 29
MINUS                : 25
MODULO               : 28
NE                   : 34
NOT                  : 37
NUMBER               : 23
OR                   : 36
PLUS                 : 24
RBRACE               : 9
RETURN               : 19
RPAREN               : 2 17 18 38
SEMI                 : 16 19 20
STRING               : 
TIMES                : 26
VOID                 : 5 7
WHILE                : 
error                : 

Nonterminals, with rules where they appear

compound_stmt        : 2 17 18 18
expr                 : 16 17 18 19 21 24 24 25 25 26 26 27 27 28 28 29 29 30 30 31 31 32 32 33 33 34 34 35 35 36 36 37 38
expr_stmt            : 12
fun_decl             : 1
if_stmt              : 13
param_list           : 2 4
program              : 0
return_stmt          : 14
stmt                 : 10 11
stmt_list            : 9 11
type                 : 2 3 4 20
var                  : 21 22
var_decl             : 15

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . fun_decl
    (2) fun_decl -> . type ID LPAREN param_list RPAREN compound_stmt
    (6) type -> . INT
    (7) type -> . VOID
    (8) type -> . CHAR

    INT             shift and go to state 4
    VOID            shift and go to state 5
    CHAR            shift and go to state 6

    program                        shift and go to state 1
    fun_decl                       shift and go to state 2
    type                           shift and go to state 3

state 1

    (0) S' -> program .



state 2

    (1) program -> fun_decl .

    $end            reduce using rule 1 (program -> fun_decl .)


state 3

    (2) fun_decl -> type . ID LPAREN param_list RPAREN compound_stmt

    ID              shift and go to state 7


state 4

    (6) type -> INT .

    ID              reduce using rule 6 (type -> INT .)


state 5

    (7) type -> VOID .

    ID              reduce using rule 7 (type -> VOID .)


state 6

    (8) type -> CHAR .

    ID              reduce using rule 8 (type -> CHAR .)


state 7

    (2) fun_decl -> type ID . LPAREN param_list RPAREN compound_stmt

    LPAREN          shift and go to state 8


state 8

    (2) fun_decl -> type ID LPAREN . param_list RPAREN compound_stmt
    (3) param_list -> . type ID
    (4) param_list -> . param_list COMMA type ID
    (5) param_list -> . VOID
    (6) type -> . INT
    (7) type -> . VOID
    (8) type -> . CHAR

    VOID            shift and go to state 11
    INT             shift and go to state 4
    CHAR            shift and go to state 6

    type                           shift and go to state 9
    param_list                     shift and go to state 10

state 9

    (3) param_list -> type . ID

    ID              shift and go to state 12


state 10

    (2) fun_decl -> type ID LPAREN param_list . RPAREN compound_stmt
    (4) param_list -> param_list . COMMA type ID

    RPAREN          shift and go to state 13
    COMMA           shift and go to state 14


state 11

    (5) param_list -> VOID .
    (7) type -> VOID .

    RPAREN          reduce using rule 5 (param_list -> VOID .)
    COMMA           reduce using rule 5 (param_list -> VOID .)
    ID              reduce using rule 7 (type -> VOID .)


state 12

    (3) param_list -> type ID .

    RPAREN          reduce using rule 3 (param_list -> type ID .)
    COMMA           reduce using rule 3 (param_list -> type ID .)


state 13

    (2) fun_decl -> type ID LPAREN param_list RPAREN . compound_stmt
    (9) compound_stmt -> . LBRACE stmt_list RBRACE

    LBRACE          shift and go to state 16

    compound_stmt                  shift and go to state 15

state 14

    (4) param_list -> param_list COMMA . type ID
    (6) type -> . INT
    (7) type -> . VOID
    (8) type -> . CHAR

    INT             shift and go to state 4
    VOID            shift and go to state 5
    CHAR            shift and go to state 6

    type                           shift and go to state 17

state 15

    (2) fun_decl -> type ID LPAREN param_list RPAREN compound_stmt .

    $end            reduce using rule 2 (fun_decl -> type ID LPAREN param_list RPAREN compound_stmt .)


state 16

    (9) compound_stmt -> LBRACE . stmt_list RBRACE
    (10) stmt_list -> . stmt
    (11) stmt_list -> . stmt stmt_list
    (12) stmt -> . expr_stmt
    (13) stmt -> . if_stmt
    (14) stmt -> . return_stmt
    (15) stmt -> . var_decl
    (16) expr_stmt -> . expr SEMI
    (17) if_stmt -> . IF LPAREN expr RPAREN compound_stmt
    (18) if_stmt -> . IF LPAREN expr RPAREN compound_stmt ELSE compound_stmt
    (19) return_stmt -> . RETURN expr SEMI
    (20) var_decl -> . type ID SEMI
    (21) expr -> . var ASSIGN expr
    (22) expr -> . var
    (23) expr -> . NUMBER
    (24) expr -> . expr PLUS expr
    (25) expr -> . expr MINUS expr
    (26) expr -> . expr TIMES expr
    (27) expr -> . expr DIVIDE expr
    (28) expr -> . expr MODULO expr
    (29) expr -> . expr LT expr
    (30) expr -> . expr LE expr
    (31) expr -> . expr GT expr
    (32) expr -> . expr GE expr
    (33) expr -> . expr EQ expr
    (34) expr -> . expr NE expr
    (35) expr -> . expr AND expr
    (36) expr -> . expr OR expr
    (37) expr -> . NOT expr
    (38) expr -> . LPAREN expr RPAREN
    (6) type -> . INT
    (7) type -> . VOID
    (8) type -> . CHAR
    (39) var -> . ID

    IF              shift and go to state 25
    RETURN          shift and go to state 27
    NUMBER          shift and go to state 31
    NOT             shift and go to state 32
    LPAREN          shift and go to state 26
    INT             shift and go to state 4
    VOID            shift and go to state 5
    CHAR            shift and go to state 6
    ID              shift and go to state 29

    stmt_list                      shift and go to state 18
    stmt                           shift and go to state 19
    expr_stmt                      shift and go to state 20
    if_stmt                        shift and go to state 21
    return_stmt                    shift and go to state 22
    var_decl                       shift and go to state 23
    expr                           shift and go to state 24
    type                           shift and go to state 28
    var                            shift and go to state 30

state 17

    (4) param_list -> param_list COMMA type . ID

    ID              shift and go to state 33


state 18

    (9) compound_stmt -> LBRACE stmt_list . RBRACE

    RBRACE          shift and go to state 34


state 19

    (10) stmt_list -> stmt .
    (11) stmt_list -> stmt . stmt_list
    (10) stmt_list -> . stmt
    (11) stmt_list -> . stmt stmt_list
    (12) stmt -> . expr_stmt
    (13) stmt -> . if_stmt
    (14) stmt -> . return_stmt
    (15) stmt -> . var_decl
    (16) expr_stmt -> . expr SEMI
    (17) if_stmt -> . IF LPAREN expr RPAREN compound_stmt
    (18) if_stmt -> . IF LPAREN expr RPAREN compound_stmt ELSE compound_stmt
    (19) return_stmt -> . RETURN expr SEMI
    (20) var_decl -> . type ID SEMI
    (21) expr -> . var ASSIGN expr
    (22) expr -> . var
    (23) expr -> . NUMBER
    (24) expr -> . expr PLUS expr
    (25) expr -> . expr MINUS expr
    (26) expr -> . expr TIMES expr
    (27) expr -> . expr DIVIDE expr
    (28) expr -> . expr MODULO expr
    (29) expr -> . expr LT expr
    (30) expr -> . expr LE expr
    (31) expr -> . expr GT expr
    (32) expr -> . expr GE expr
    (33) expr -> . expr EQ expr
    (34) expr -> . expr NE expr
    (35) expr -> . expr AND expr
    (36) expr -> . expr OR expr
    (37) expr -> . NOT expr
    (38) expr -> . LPAREN expr RPAREN
    (6) type -> . INT
    (7) type -> . VOID
    (8) type -> . CHAR
    (39) var -> . ID

    RBRACE          reduce using rule 10 (stmt_list -> stmt .)
    IF              shift and go to state 25
    RETURN          shift and go to state 27
    NUMBER          shift and go to state 31
    NOT             shift and go to state 32
    LPAREN          shift and go to state 26
    INT             shift and go to state 4
    VOID            shift and go to state 5
    CHAR            shift and go to state 6
    ID              shift and go to state 29

    stmt                           shift and go to state 19
    stmt_list                      shift and go to state 35
    expr_stmt                      shift and go to state 20
    if_stmt                        shift and go to state 21
    return_stmt                    shift and go to state 22
    var_decl                       shift and go to state 23
    expr                           shift and go to state 24
    type                           shift and go to state 28
    var                            shift and go to state 30

state 20

    (12) stmt -> expr_stmt .

    IF              reduce using rule 12 (stmt -> expr_stmt .)
    RETURN          reduce using rule 12 (stmt -> expr_stmt .)
    NUMBER          reduce using rule 12 (stmt -> expr_stmt .)
    NOT             reduce using rule 12 (stmt -> expr_stmt .)
    LPAREN          reduce using rule 12 (stmt -> expr_stmt .)
    INT             reduce using rule 12 (stmt -> expr_stmt .)
    VOID            reduce using rule 12 (stmt -> expr_stmt .)
    CHAR            reduce using rule 12 (stmt -> expr_stmt .)
    ID              reduce using rule 12 (stmt -> expr_stmt .)
    RBRACE          reduce using rule 12 (stmt -> expr_stmt .)


state 21

    (13) stmt -> if_stmt .

    IF              reduce using rule 13 (stmt -> if_stmt .)
    RETURN          reduce using rule 13 (stmt -> if_stmt .)
    NUMBER          reduce using rule 13 (stmt -> if_stmt .)
    NOT             reduce using rule 13 (stmt -> if_stmt .)
    LPAREN          reduce using rule 13 (stmt -> if_stmt .)
    INT             reduce using rule 13 (stmt -> if_stmt .)
    VOID            reduce using rule 13 (stmt -> if_stmt .)
    CHAR            reduce using rule 13 (stmt -> if_stmt .)
    ID              reduce using rule 13 (stmt -> if_stmt .)
    RBRACE          reduce using rule 13 (stmt -> if_stmt .)


state 22

    (14) stmt -> return_stmt .

    IF              reduce using rule 14 (stmt -> return_stmt .)
    RETURN          reduce using rule 14 (stmt -> return_stmt .)
    NUMBER          reduce using rule 14 (stmt -> return_stmt .)
    NOT             reduce using rule 14 (stmt -> return_stmt .)
    LPAREN          reduce using rule 14 (stmt -> return_stmt .)
    INT             reduce using rule 14 (stmt -> return_stmt .)
    VOID            reduce using rule 14 (stmt -> return_stmt .)
    CHAR            reduce using rule 14 (stmt -> return_stmt .)
    ID              reduce using rule 14 (stmt -> return_stmt .)
    RBRACE          reduce using rule 14 (stmt -> return_stmt .)


state 23

    (15) stmt -> var_decl .

    IF              reduce using rule 15 (stmt -> var_decl .)
    RETURN          reduce using rule 15 (stmt -> var_decl .)
    NUMBER          reduce using rule 15 (stmt -> var_decl .)
    NOT             reduce using rule 15 (stmt -> var_decl .)
    LPAREN          reduce using rule 15 (stmt -> var_decl .)
    INT             reduce using rule 15 (stmt -> var_decl .)
    VOID            reduce using rule 15 (stmt -> var_decl .)
    CHAR            reduce using rule 15 (stmt -> var_decl .)
    ID              reduce using rule 15 (stmt -> var_decl .)
    RBRACE          reduce using rule 15 (stmt -> var_decl .)


state 24

    (16) expr_stmt -> expr . SEMI
    (24) expr -> expr . PLUS expr
    (25) expr -> expr . MINUS expr
    (26) expr -> expr . TIMES expr
    (27) expr -> expr . DIVIDE expr
    (28) expr -> expr . MODULO expr
    (29) expr -> expr . LT expr
    (30) expr -> expr . LE expr
    (31) expr -> expr . GT expr
    (32) expr -> expr . GE expr
    (33) expr -> expr . EQ expr
    (34) expr -> expr . NE expr
    (35) expr -> expr . AND expr
    (36) expr -> expr . OR expr

    SEMI            shift and go to state 36
    PLUS            shift and go to state 37
    MINUS           shift and go to state 38
    TIMES           shift and go to state 39
    DIVIDE          shift and go to state 40
    MODULO          shift and go to state 41
    LT              shift and go to state 42
    LE              shift and go to state 43
    GT              shift and go to state 44
    GE              shift and go to state 45
    EQ              shift and go to state 46
    NE              shift and go to state 47
    AND             shift and go to state 48
    OR              shift and go to state 49


state 25

    (17) if_stmt -> IF . LPAREN expr RPAREN compound_stmt
    (18) if_stmt -> IF . LPAREN expr RPAREN compound_stmt ELSE compound_stmt

    LPAREN          shift and go to state 50


state 26

    (38) expr -> LPAREN . expr RPAREN
    (21) expr -> . var ASSIGN expr
    (22) expr -> . var
    (23) expr -> . NUMBER
    (24) expr -> . expr PLUS expr
    (25) expr -> . expr MINUS expr
    (26) expr -> . expr TIMES expr
    (27) expr -> . expr DIVIDE expr
    (28) expr -> . expr MODULO expr
    (29) expr -> . expr LT expr
    (30) expr -> . expr LE expr
    (31) expr -> . expr GT expr
    (32) expr -> . expr GE expr
    (33) expr -> . expr EQ expr
    (34) expr -> . expr NE expr
    (35) expr -> . expr AND expr
    (36) expr -> . expr OR expr
    (37) expr -> . NOT expr
    (38) expr -> . LPAREN expr RPAREN
    (39) var -> . ID

    NUMBER          shift and go to state 31
    NOT             shift and go to state 32
    LPAREN          shift and go to state 26
    ID              shift and go to state 29

    expr                           shift and go to state 51
    var                            shift and go to state 30

state 27

    (19) return_stmt -> RETURN . expr SEMI
    (21) expr -> . var ASSIGN expr
    (22) expr -> . var
    (23) expr -> . NUMBER
    (24) expr -> . expr PLUS expr
    (25) expr -> . expr MINUS expr
    (26) expr -> . expr TIMES expr
    (27) expr -> . expr DIVIDE expr
    (28) expr -> . expr MODULO expr
    (29) expr -> . expr LT expr
    (30) expr -> . expr LE expr
    (31) expr -> . expr GT expr
    (32) expr -> . expr GE expr
    (33) expr -> . expr EQ expr
    (34) expr -> . expr NE expr
    (35) expr -> . expr AND expr
    (36) expr -> . expr OR expr
    (37) expr -> . NOT expr
    (38) expr -> . LPAREN expr RPAREN
    (39) var -> . ID

    NUMBER          shift and go to state 31
    NOT             shift and go to state 32
    LPAREN          shift and go to state 26
    ID              shift and go to state 29

    expr                           shift and go to state 52
    var                            shift and go to state 30

state 28

    (20) var_decl -> type . ID SEMI

    ID              shift and go to state 53


state 29

    (39) var -> ID .

    ASSIGN          reduce using rule 39 (var -> ID .)
    SEMI            reduce using rule 39 (var -> ID .)
    PLUS            reduce using rule 39 (var -> ID .)
    MINUS           reduce using rule 39 (var -> ID .)
    TIMES           reduce using rule 39 (var -> ID .)
    DIVIDE          reduce using rule 39 (var -> ID .)
    MODULO          reduce using rule 39 (var -> ID .)
    LT              reduce using rule 39 (var -> ID .)
    LE              reduce using rule 39 (var -> ID .)
    GT              reduce using rule 39 (var -> ID .)
    GE              reduce using rule 39 (var -> ID .)
    EQ              reduce using rule 39 (var -> ID .)
    NE              reduce using rule 39 (var -> ID .)
    AND             reduce using rule 39 (var -> ID .)
    OR              reduce using rule 39 (var -> ID .)
    RPAREN          reduce using rule 39 (var -> ID .)


state 30

    (21) expr -> var . ASSIGN expr
    (22) expr -> var .

    ASSIGN          shift and go to state 54
    SEMI            reduce using rule 22 (expr -> var .)
    PLUS            reduce using rule 22 (expr -> var .)
    MINUS           reduce using rule 22 (expr -> var .)
    TIMES           reduce using rule 22 (expr -> var .)
    DIVIDE          reduce using rule 22 (expr -> var .)
    MODULO          reduce using rule 22 (expr -> var .)
    LT              reduce using rule 22 (expr -> var .)
    LE              reduce using rule 22 (expr -> var .)
    GT              reduce using rule 22 (expr -> var .)
    GE              reduce using rule 22 (expr -> var .)
    EQ              reduce using rule 22 (expr -> var .)
    NE              reduce using rule 22 (expr -> var .)
    AND             reduce using rule 22 (expr -> var .)
    OR              reduce using rule 22 (expr -> var .)
    RPAREN          reduce using rule 22 (expr -> var .)


state 31

    (23) expr -> NUMBER .

    SEMI            reduce using rule 23 (expr -> NUMBER .)
    PLUS            reduce using rule 23 (expr -> NUMBER .)
    MINUS           reduce using rule 23 (expr -> NUMBER .)
    TIMES           reduce using rule 23 (expr -> NUMBER .)
    DIVIDE          reduce using rule 23 (expr -> NUMBER .)
    MODULO          reduce using rule 23 (expr -> NUMBER .)
    LT              reduce using rule 23 (expr -> NUMBER .)
    LE              reduce using rule 23 (expr -> NUMBER .)
    GT              reduce using rule 23 (expr -> NUMBER .)
    GE              reduce using rule 23 (expr -> NUMBER .)
    EQ              reduce using rule 23 (expr -> NUMBER .)
    NE              reduce using rule 23 (expr -> NUMBER .)
    AND             reduce using rule 23 (expr -> NUMBER .)
    OR              reduce using rule 23 (expr -> NUMBER .)
    RPAREN          reduce using rule 23 (expr -> NUMBER .)


state 32

    (37) expr -> NOT . expr
    (21) expr -> . var ASSIGN expr
    (22) expr -> . var
    (23) expr -> . NUMBER
    (24) expr -> . expr PLUS expr
    (25) expr -> . expr MINUS expr
    (26) expr -> . expr TIMES expr
    (27) expr -> . expr DIVIDE expr
    (28) expr -> . expr MODULO expr
    (29) expr -> . expr LT expr
    (30) expr -> . expr LE expr
    (31) expr -> . expr GT expr
    (32) expr -> . expr GE expr
    (33) expr -> . expr EQ expr
    (34) expr -> . expr NE expr
    (35) expr -> . expr AND expr
    (36) expr -> . expr OR expr
    (37) expr -> . NOT expr
    (38) expr -> . LPAREN expr RPAREN
    (39) var -> . ID

    NUMBER          shift and go to state 31
    NOT             shift and go to state 32
    LPAREN          shift and go to state 26
    ID              shift and go to state 29

    expr                           shift and go to state 55
    var                            shift and go to state 30

state 33

    (4) param_list -> param_list COMMA type ID .

    RPAREN          reduce using rule 4 (param_list -> param_list COMMA type ID .)
    COMMA           reduce using rule 4 (param_list -> param_list COMMA type ID .)


state 34

    (9) compound_stmt -> LBRACE stmt_list RBRACE .

    $end            reduce using rule 9 (compound_stmt -> LBRACE stmt_list RBRACE .)
    ELSE            reduce using rule 9 (compound_stmt -> LBRACE stmt_list RBRACE .)
    IF              reduce using rule 9 (compound_stmt -> LBRACE stmt_list RBRACE .)
    RETURN          reduce using rule 9 (compound_stmt -> LBRACE stmt_list RBRACE .)
    NUMBER          reduce using rule 9 (compound_stmt -> LBRACE stmt_list RBRACE .)
    NOT             reduce using rule 9 (compound_stmt -> LBRACE stmt_list RBRACE .)
    LPAREN          reduce using rule 9 (compound_stmt -> LBRACE stmt_list RBRACE .)
    INT             reduce using rule 9 (compound_stmt -> LBRACE stmt_list RBRACE .)
    VOID            reduce using rule 9 (compound_stmt -> LBRACE stmt_list RBRACE .)
    CHAR            reduce using rule 9 (compound_stmt -> LBRACE stmt_list RBRACE .)
    ID              reduce using rule 9 (compound_stmt -> LBRACE stmt_list RBRACE .)
    RBRACE          reduce using rule 9 (compound_stmt -> LBRACE stmt_list RBRACE .)


state 35

    (11) stmt_list -> stmt stmt_list .

    RBRACE          reduce using rule 11 (stmt_list -> stmt stmt_list .)


state 36

    (16) expr_stmt -> expr SEMI .

    IF              reduce using rule 16 (expr_stmt -> expr SEMI .)
    RETURN          reduce using rule 16 (expr_stmt -> expr SEMI .)
    NUMBER          reduce using rule 16 (expr_stmt -> expr SEMI .)
    NOT             reduce using rule 16 (expr_stmt -> expr SEMI .)
    LPAREN          reduce using rule 16 (expr_stmt -> expr SEMI .)
    INT             reduce using rule 16 (expr_stmt -> expr SEMI .)
    VOID            reduce using rule 16 (expr_stmt -> expr SEMI .)
    CHAR            reduce using rule 16 (expr_stmt -> expr SEMI .)
    ID              reduce using rule 16 (expr_stmt -> expr SEMI .)
    RBRACE          reduce using rule 16 (expr_stmt -> expr SEMI .)


state 37

    (24) expr -> expr PLUS . expr
    (21) expr -> . var ASSIGN expr
    (22) expr -> . var
    (23) expr -> . NUMBER
    (24) expr -> . expr PLUS expr
    (25) expr -> . expr MINUS expr
    (26) expr -> . expr TIMES expr
    (27) expr -> . expr DIVIDE expr
    (28) expr -> . expr MODULO expr
    (29) expr -> . expr LT expr
    (30) expr -> . expr LE expr
    (31) expr -> . expr GT expr
    (32) expr -> . expr GE expr
    (33) expr -> . expr EQ expr
    (34) expr -> . expr NE expr
    (35) expr -> . expr AND expr
    (36) expr -> . expr OR expr
    (37) expr -> . NOT expr
    (38) expr -> . LPAREN expr RPAREN
    (39) var -> . ID

    NUMBER          shift and go to state 31
    NOT             shift and go to state 32
    LPAREN          shift and go to state 26
    ID              shift and go to state 29

    expr                           shift and go to state 56
    var                            shift and go to state 30

state 38

    (25) expr -> expr MINUS . expr
    (21) expr -> . var ASSIGN expr
    (22) expr -> . var
    (23) expr -> . NUMBER
    (24) expr -> . expr PLUS expr
    (25) expr -> . expr MINUS expr
    (26) expr -> . expr TIMES expr
    (27) expr -> . expr DIVIDE expr
    (28) expr -> . expr MODULO expr
    (29) expr -> . expr LT expr
    (30) expr -> . expr LE expr
    (31) expr -> . expr GT expr
    (32) expr -> . expr GE expr
    (33) expr -> . expr EQ expr
    (34) expr -> . expr NE expr
    (35) expr -> . expr AND expr
    (36) expr -> . expr OR expr
    (37) expr -> . NOT expr
    (38) expr -> . LPAREN expr RPAREN
    (39) var -> . ID

    NUMBER          shift and go to state 31
    NOT             shift and go to state 32
    LPAREN          shift and go to state 26
    ID              shift and go to state 29

    expr                           shift and go to state 57
    var                            shift and go to state 30

state 39

    (26) expr -> expr TIMES . expr
    (21) expr -> . var ASSIGN expr
    (22) expr -> . var
    (23) expr -> . NUMBER
    (24) expr -> . expr PLUS expr
    (25) expr -> . expr MINUS expr
    (26) expr -> . expr TIMES expr
    (27) expr -> . expr DIVIDE expr
    (28) expr -> . expr MODULO expr
    (29) expr -> . expr LT expr
    (30) expr -> . expr LE expr
    (31) expr -> . expr GT expr
    (32) expr -> . expr GE expr
    (33) expr -> . expr EQ expr
    (34) expr -> . expr NE expr
    (35) expr -> . expr AND expr
    (36) expr -> . expr OR expr
    (37) expr -> . NOT expr
    (38) expr -> . LPAREN expr RPAREN
    (39) var -> . ID

    NUMBER          shift and go to state 31
    NOT             shift and go to state 32
    LPAREN          shift and go to state 26
    ID              shift and go to state 29

    expr                           shift and go to state 58
    var                            shift and go to state 30

state 40

    (27) expr -> expr DIVIDE . expr
    (21) expr -> . var ASSIGN expr
    (22) expr -> . var
    (23) expr -> . NUMBER
    (24) expr -> . expr PLUS expr
    (25) expr -> . expr MINUS expr
    (26) expr -> . expr TIMES expr
    (27) expr -> . expr DIVIDE expr
    (28) expr -> . expr MODULO expr
    (29) expr -> . expr LT expr
    (30) expr -> . expr LE expr
    (31) expr -> . expr GT expr
    (32) expr -> . expr GE expr
    (33) expr -> . expr EQ expr
    (34) expr -> . expr NE expr
    (35) expr -> . expr AND expr
    (36) expr -> . expr OR expr
    (37) expr -> . NOT expr
    (38) expr -> . LPAREN expr RPAREN
    (39) var -> . ID

    NUMBER          shift and go to state 31
    NOT             shift and go to state 32
    LPAREN          shift and go to state 26
    ID              shift and go to state 29

    expr                           shift and go to state 59
    var                            shift and go to state 30

state 41

    (28) expr -> expr MODULO . expr
    (21) expr -> . var ASSIGN expr
    (22) expr -> . var
    (23) expr -> . NUMBER
    (24) expr -> . expr PLUS expr
    (25) expr -> . expr MINUS expr
    (26) expr -> . expr TIMES expr
    (27) expr -> . expr DIVIDE expr
    (28) expr -> . expr MODULO expr
    (29) expr -> . expr LT expr
    (30) expr -> . expr LE expr
    (31) expr -> . expr GT expr
    (32) expr -> . expr GE expr
    (33) expr -> . expr EQ expr
    (34) expr -> . expr NE expr
    (35) expr -> . expr AND expr
    (36) expr -> . expr OR expr
    (37) expr -> . NOT expr
    (38) expr -> . LPAREN expr RPAREN
    (39) var -> . ID

    NUMBER          shift and go to state 31
    NOT             shift and go to state 32
    LPAREN          shift and go to state 26
    ID              shift and go to state 29

    expr                           shift and go to state 60
    var                            shift and go to state 30

state 42

    (29) expr -> expr LT . expr
    (21) expr -> . var ASSIGN expr
    (22) expr -> . var
    (23) expr -> . NUMBER
    (24) expr -> . expr PLUS expr
    (25) expr -> . expr MINUS expr
    (26) expr -> . expr TIMES expr
    (27) expr -> . expr DIVIDE expr
    (28) expr -> . expr MODULO expr
    (29) expr -> . expr LT expr
    (30) expr -> . expr LE expr
    (31) expr -> . expr GT expr
    (32) expr -> . expr GE expr
    (33) expr -> . expr EQ expr
    (34) expr -> . expr NE expr
    (35) expr -> . expr AND expr
    (36) expr -> . expr OR expr
    (37) expr -> . NOT expr
    (38) expr -> . LPAREN expr RPAREN
    (39) var -> . ID

    NUMBER          shift and go to state 31
    NOT             shift and go to state 32
    LPAREN          shift and go to state 26
    ID              shift and go to state 29

    expr                           shift and go to state 61
    var                            shift and go to state 30

state 43

    (30) expr -> expr LE . expr
    (21) expr -> . var ASSIGN expr
    (22) expr -> . var
    (23) expr -> . NUMBER
    (24) expr -> . expr PLUS expr
    (25) expr -> . expr MINUS expr
    (26) expr -> . expr TIMES expr
    (27) expr -> . expr DIVIDE expr
    (28) expr -> . expr MODULO expr
    (29) expr -> . expr LT expr
    (30) expr -> . expr LE expr
    (31) expr -> . expr GT expr
    (32) expr -> . expr GE expr
    (33) expr -> . expr EQ expr
    (34) expr -> . expr NE expr
    (35) expr -> . expr AND expr
    (36) expr -> . expr OR expr
    (37) expr -> . NOT expr
    (38) expr -> . LPAREN expr RPAREN
    (39) var -> . ID

    NUMBER          shift and go to state 31
    NOT             shift and go to state 32
    LPAREN          shift and go to state 26
    ID              shift and go to state 29

    expr                           shift and go to state 62
    var                            shift and go to state 30

state 44

    (31) expr -> expr GT . expr
    (21) expr -> . var ASSIGN expr
    (22) expr -> . var
    (23) expr -> . NUMBER
    (24) expr -> . expr PLUS expr
    (25) expr -> . expr MINUS expr
    (26) expr -> . expr TIMES expr
    (27) expr -> . expr DIVIDE expr
    (28) expr -> . expr MODULO expr
    (29) expr -> . expr LT expr
    (30) expr -> . expr LE expr
    (31) expr -> . expr GT expr
    (32) expr -> . expr GE expr
    (33) expr -> . expr EQ expr
    (34) expr -> . expr NE expr
    (35) expr -> . expr AND expr
    (36) expr -> . expr OR expr
    (37) expr -> . NOT expr
    (38) expr -> . LPAREN expr RPAREN
    (39) var -> . ID

    NUMBER          shift and go to state 31
    NOT             shift and go to state 32
    LPAREN          shift and go to state 26
    ID              shift and go to state 29

    expr                           shift and go to state 63
    var                            shift and go to state 30

state 45

    (32) expr -> expr GE . expr
    (21) expr -> . var ASSIGN expr
    (22) expr -> . var
    (23) expr -> . NUMBER
    (24) expr -> . expr PLUS expr
    (25) expr -> . expr MINUS expr
    (26) expr -> . expr TIMES expr
    (27) expr -> . expr DIVIDE expr
    (28) expr -> . expr MODULO expr
    (29) expr -> . expr LT expr
    (30) expr -> . expr LE expr
    (31) expr -> . expr GT expr
    (32) expr -> . expr GE expr
    (33) expr -> . expr EQ expr
    (34) expr -> . expr NE expr
    (35) expr -> . expr AND expr
    (36) expr -> . expr OR expr
    (37) expr -> . NOT expr
    (38) expr -> . LPAREN expr RPAREN
    (39) var -> . ID

    NUMBER          shift and go to state 31
    NOT             shift and go to state 32
    LPAREN          shift and go to state 26
    ID              shift and go to state 29

    expr                           shift and go to state 64
    var                            shift and go to state 30

state 46

    (33) expr -> expr EQ . expr
    (21) expr -> . var ASSIGN expr
    (22) expr -> . var
    (23) expr -> . NUMBER
    (24) expr -> . expr PLUS expr
    (25) expr -> . expr MINUS expr
    (26) expr -> . expr TIMES expr
    (27) expr -> . expr DIVIDE expr
    (28) expr -> . expr MODULO expr
    (29) expr -> . expr LT expr
    (30) expr -> . expr LE expr
    (31) expr -> . expr GT expr
    (32) expr -> . expr GE expr
    (33) expr -> . expr EQ expr
    (34) expr -> . expr NE expr
    (35) expr -> . expr AND expr
    (36) expr -> . expr OR expr
    (37) expr -> . NOT expr
    (38) expr -> . LPAREN expr RPAREN
    (39) var -> . ID

    NUMBER          shift and go to state 31
    NOT             shift and go to state 32
    LPAREN          shift and go to state 26
    ID              shift and go to state 29

    expr                           shift and go to state 65
    var                            shift and go to state 30

state 47

    (34) expr -> expr NE . expr
    (21) expr -> . var ASSIGN expr
    (22) expr -> . var
    (23) expr -> . NUMBER
    (24) expr -> . expr PLUS expr
    (25) expr -> . expr MINUS expr
    (26) expr -> . expr TIMES expr
    (27) expr -> . expr DIVIDE expr
    (28) expr -> . expr MODULO expr
    (29) expr -> . expr LT expr
    (30) expr -> . expr LE expr
    (31) expr -> . expr GT expr
    (32) expr -> . expr GE expr
    (33) expr -> . expr EQ expr
    (34) expr -> . expr NE expr
    (35) expr -> . expr AND expr
    (36) expr -> . expr OR expr
    (37) expr -> . NOT expr
    (38) expr -> . LPAREN expr RPAREN
    (39) var -> . ID

    NUMBER          shift and go to state 31
    NOT             shift and go to state 32
    LPAREN          shift and go to state 26
    ID              shift and go to state 29

    expr                           shift and go to state 66
    var                            shift and go to state 30

state 48

    (35) expr -> expr AND . expr
    (21) expr -> . var ASSIGN expr
    (22) expr -> . var
    (23) expr -> . NUMBER
    (24) expr -> . expr PLUS expr
    (25) expr -> . expr MINUS expr
    (26) expr -> . expr TIMES expr
    (27) expr -> . expr DIVIDE expr
    (28) expr -> . expr MODULO expr
    (29) expr -> . expr LT expr
    (30) expr -> . expr LE expr
    (31) expr -> . expr GT expr
    (32) expr -> . expr GE expr
    (33) expr -> . expr EQ expr
    (34) expr -> . expr NE expr
    (35) expr -> . expr AND expr
    (36) expr -> . expr OR expr
    (37) expr -> . NOT expr
    (38) expr -> . LPAREN expr RPAREN
    (39) var -> . ID

    NUMBER          shift and go to state 31
    NOT             shift and go to state 32
    LPAREN          shift and go to state 26
    ID              shift and go to state 29

    expr                           shift and go to state 67
    var                            shift and go to state 30

state 49

    (36) expr -> expr OR . expr
    (21) expr -> . var ASSIGN expr
    (22) expr -> . var
    (23) expr -> . NUMBER
    (24) expr -> . expr PLUS expr
    (25) expr -> . expr MINUS expr
    (26) expr -> . expr TIMES expr
    (27) expr -> . expr DIVIDE expr
    (28) expr -> . expr MODULO expr
    (29) expr -> . expr LT expr
    (30) expr -> . expr LE expr
    (31) expr -> . expr GT expr
    (32) expr -> . expr GE expr
    (33) expr -> . expr EQ expr
    (34) expr -> . expr NE expr
    (35) expr -> . expr AND expr
    (36) expr -> . expr OR expr
    (37) expr -> . NOT expr
    (38) expr -> . LPAREN expr RPAREN
    (39) var -> . ID

    NUMBER          shift and go to state 31
    NOT             shift and go to state 32
    LPAREN          shift and go to state 26
    ID              shift and go to state 29

    expr                           shift and go to state 68
    var                            shift and go to state 30

state 50

    (17) if_stmt -> IF LPAREN . expr RPAREN compound_stmt
    (18) if_stmt -> IF LPAREN . expr RPAREN compound_stmt ELSE compound_stmt
    (21) expr -> . var ASSIGN expr
    (22) expr -> . var
    (23) expr -> . NUMBER
    (24) expr -> . expr PLUS expr
    (25) expr -> . expr MINUS expr
    (26) expr -> . expr TIMES expr
    (27) expr -> . expr DIVIDE expr
    (28) expr -> . expr MODULO expr
    (29) expr -> . expr LT expr
    (30) expr -> . expr LE expr
    (31) expr -> . expr GT expr
    (32) expr -> . expr GE expr
    (33) expr -> . expr EQ expr
    (34) expr -> . expr NE expr
    (35) expr -> . expr AND expr
    (36) expr -> . expr OR expr
    (37) expr -> . NOT expr
    (38) expr -> . LPAREN expr RPAREN
    (39) var -> . ID

    NUMBER          shift and go to state 31
    NOT             shift and go to state 32
    LPAREN          shift and go to state 26
    ID              shift and go to state 29

    expr                           shift and go to state 69
    var                            shift and go to state 30

state 51

    (38) expr -> LPAREN expr . RPAREN
    (24) expr -> expr . PLUS expr
    (25) expr -> expr . MINUS expr
    (26) expr -> expr . TIMES expr
    (27) expr -> expr . DIVIDE expr
    (28) expr -> expr . MODULO expr
    (29) expr -> expr . LT expr
    (30) expr -> expr . LE expr
    (31) expr -> expr . GT expr
    (32) expr -> expr . GE expr
    (33) expr -> expr . EQ expr
    (34) expr -> expr . NE expr
    (35) expr -> expr . AND expr
    (36) expr -> expr . OR expr

    RPAREN          shift and go to state 70
    PLUS            shift and go to state 37
    MINUS           shift and go to state 38
    TIMES           shift and go to state 39
    DIVIDE          shift and go to state 40
    MODULO          shift and go to state 41
    LT              shift and go to state 42
    LE              shift and go to state 43
    GT              shift and go to state 44
    GE              shift and go to state 45
    EQ              shift and go to state 46
    NE              shift and go to state 47
    AND             shift and go to state 48
    OR              shift and go to state 49


state 52

    (19) return_stmt -> RETURN expr . SEMI
    (24) expr -> expr . PLUS expr
    (25) expr -> expr . MINUS expr
    (26) expr -> expr . TIMES expr
    (27) expr -> expr . DIVIDE expr
    (28) expr -> expr . MODULO expr
    (29) expr -> expr . LT expr
    (30) expr -> expr . LE expr
    (31) expr -> expr . GT expr
    (32) expr -> expr . GE expr
    (33) expr -> expr . EQ expr
    (34) expr -> expr . NE expr
    (35) expr -> expr . AND expr
    (36) expr -> expr . OR expr

    SEMI            shift and go to state 71
    PLUS            shift and go to state 37
    MINUS           shift and go to state 38
    TIMES           shift and go to state 39
    DIVIDE          shift and go to state 40
    MODULO          shift and go to state 41
    LT              shift and go to state 42
    LE              shift and go to state 43
    GT              shift and go to state 44
    GE              shift and go to state 45
    EQ              shift and go to state 46
    NE              shift and go to state 47
    AND             shift and go to state 48
    OR              shift and go to state 49


state 53

    (20) var_decl -> type ID . SEMI

    SEMI            shift and go to state 72


state 54

    (21) expr -> var ASSIGN . expr
    (21) expr -> . var ASSIGN expr
    (22) expr -> . var
    (23) expr -> . NUMBER
    (24) expr -> . expr PLUS expr
    (25) expr -> . expr MINUS expr
    (26) expr -> . expr TIMES expr
    (27) expr -> . expr DIVIDE expr
    (28) expr -> . expr MODULO expr
    (29) expr -> . expr LT expr
    (30) expr -> . expr LE expr
    (31) expr -> . expr GT expr
    (32) expr -> . expr GE expr
    (33) expr -> . expr EQ expr
    (34) expr -> . expr NE expr
    (35) expr -> . expr AND expr
    (36) expr -> . expr OR expr
    (37) expr -> . NOT expr
    (38) expr -> . LPAREN expr RPAREN
    (39) var -> . ID

    NUMBER          shift and go to state 31
    NOT             shift and go to state 32
    LPAREN          shift and go to state 26
    ID              shift and go to state 29

    var                            shift and go to state 30
    expr                           shift and go to state 73

state 55

    (37) expr -> NOT expr .
    (24) expr -> expr . PLUS expr
    (25) expr -> expr . MINUS expr
    (26) expr -> expr . TIMES expr
    (27) expr -> expr . DIVIDE expr
    (28) expr -> expr . MODULO expr
    (29) expr -> expr . LT expr
    (30) expr -> expr . LE expr
    (31) expr -> expr . GT expr
    (32) expr -> expr . GE expr
    (33) expr -> expr . EQ expr
    (34) expr -> expr . NE expr
    (35) expr -> expr . AND expr
    (36) expr -> expr . OR expr

    SEMI            reduce using rule 37 (expr -> NOT expr .)
    PLUS            reduce using rule 37 (expr -> NOT expr .)
    MINUS           reduce using rule 37 (expr -> NOT expr .)
    TIMES           reduce using rule 37 (expr -> NOT expr .)
    DIVIDE          reduce using rule 37 (expr -> NOT expr .)
    MODULO          reduce using rule 37 (expr -> NOT expr .)
    LT              reduce using rule 37 (expr -> NOT expr .)
    LE              reduce using rule 37 (expr -> NOT expr .)
    GT              reduce using rule 37 (expr -> NOT expr .)
    GE              reduce using rule 37 (expr -> NOT expr .)
    EQ              reduce using rule 37 (expr -> NOT expr .)
    NE              reduce using rule 37 (expr -> NOT expr .)
    AND             reduce using rule 37 (expr -> NOT expr .)
    OR              reduce using rule 37 (expr -> NOT expr .)
    RPAREN          reduce using rule 37 (expr -> NOT expr .)

  ! PLUS            [ shift and go to state 37 ]
  ! MINUS           [ shift and go to state 38 ]
  ! TIMES           [ shift and go to state 39 ]
  ! DIVIDE          [ shift and go to state 40 ]
  ! MODULO          [ shift and go to state 41 ]
  ! LT              [ shift and go to state 42 ]
  ! LE              [ shift and go to state 43 ]
  ! GT              [ shift and go to state 44 ]
  ! GE              [ shift and go to state 45 ]
  ! EQ              [ shift and go to state 46 ]
  ! NE              [ shift and go to state 47 ]
  ! AND             [ shift and go to state 48 ]
  ! OR              [ shift and go to state 49 ]


state 56

    (24) expr -> expr PLUS expr .
    (24) expr -> expr . PLUS expr
    (25) expr -> expr . MINUS expr
    (26) expr -> expr . TIMES expr
    (27) expr -> expr . DIVIDE expr
    (28) expr -> expr . MODULO expr
    (29) expr -> expr . LT expr
    (30) expr -> expr . LE expr
    (31) expr -> expr . GT expr
    (32) expr -> expr . GE expr
    (33) expr -> expr . EQ expr
    (34) expr -> expr . NE expr
    (35) expr -> expr . AND expr
    (36) expr -> expr . OR expr

    SEMI            reduce using rule 24 (expr -> expr PLUS expr .)
    PLUS            reduce using rule 24 (expr -> expr PLUS expr .)
    MINUS           reduce using rule 24 (expr -> expr PLUS expr .)
    RPAREN          reduce using rule 24 (expr -> expr PLUS expr .)
    TIMES           shift and go to state 39
    DIVIDE          shift and go to state 40
    MODULO          shift and go to state 41
    LT              shift and go to state 42
    LE              shift and go to state 43
    GT              shift and go to state 44
    GE              shift and go to state 45
    EQ              shift and go to state 46
    NE              shift and go to state 47
    AND             shift and go to state 48
    OR              shift and go to state 49

  ! TIMES           [ reduce using rule 24 (expr -> expr PLUS expr .) ]
  ! DIVIDE          [ reduce using rule 24 (expr -> expr PLUS expr .) ]
  ! MODULO          [ reduce using rule 24 (expr -> expr PLUS expr .) ]
  ! LT              [ reduce using rule 24 (expr -> expr PLUS expr .) ]
  ! LE              [ reduce using rule 24 (expr -> expr PLUS expr .) ]
  ! GT              [ reduce using rule 24 (expr -> expr PLUS expr .) ]
  ! GE              [ reduce using rule 24 (expr -> expr PLUS expr .) ]
  ! EQ              [ reduce using rule 24 (expr -> expr PLUS expr .) ]
  ! NE              [ reduce using rule 24 (expr -> expr PLUS expr .) ]
  ! AND             [ reduce using rule 24 (expr -> expr PLUS expr .) ]
  ! OR              [ reduce using rule 24 (expr -> expr PLUS expr .) ]
  ! PLUS            [ shift and go to state 37 ]
  ! MINUS           [ shift and go to state 38 ]


state 57

    (25) expr -> expr MINUS expr .
    (24) expr -> expr . PLUS expr
    (25) expr -> expr . MINUS expr
    (26) expr -> expr . TIMES expr
    (27) expr -> expr . DIVIDE expr
    (28) expr -> expr . MODULO expr
    (29) expr -> expr . LT expr
    (30) expr -> expr . LE expr
    (31) expr -> expr . GT expr
    (32) expr -> expr . GE expr
    (33) expr -> expr . EQ expr
    (34) expr -> expr . NE expr
    (35) expr -> expr . AND expr
    (36) expr -> expr . OR expr

    SEMI            reduce using rule 25 (expr -> expr MINUS expr .)
    PLUS            reduce using rule 25 (expr -> expr MINUS expr .)
    MINUS           reduce using rule 25 (expr -> expr MINUS expr .)
    RPAREN          reduce using rule 25 (expr -> expr MINUS expr .)
    TIMES           shift and go to state 39
    DIVIDE          shift and go to state 40
    MODULO          shift and go to state 41
    LT              shift and go to state 42
    LE              shift and go to state 43
    GT              shift and go to state 44
    GE              shift and go to state 45
    EQ              shift and go to state 46
    NE              shift and go to state 47
    AND             shift and go to state 48
    OR              shift and go to state 49

  ! TIMES           [ reduce using rule 25 (expr -> expr MINUS expr .) ]
  ! DIVIDE          [ reduce using rule 25 (expr -> expr MINUS expr .) ]
  ! MODULO          [ reduce using rule 25 (expr -> expr MINUS expr .) ]
  ! LT              [ reduce using rule 25 (expr -> expr MINUS expr .) ]
  ! LE              [ reduce using rule 25 (expr -> expr MINUS expr .) ]
  ! GT              [ reduce using rule 25 (expr -> expr MINUS expr .) ]
  ! GE              [ reduce using rule 25 (expr -> expr MINUS expr .) ]
  ! EQ              [ reduce using rule 25 (expr -> expr MINUS expr .) ]
  ! NE              [ reduce using rule 25 (expr -> expr MINUS expr .) ]
  ! AND             [ reduce using rule 25 (expr -> expr MINUS expr .) ]
  ! OR              [ reduce using rule 25 (expr -> expr MINUS expr .) ]
  ! PLUS            [ shift and go to state 37 ]
  ! MINUS           [ shift and go to state 38 ]


state 58

    (26) expr -> expr TIMES expr .
    (24) expr -> expr . PLUS expr
    (25) expr -> expr . MINUS expr
    (26) expr -> expr . TIMES expr
    (27) expr -> expr . DIVIDE expr
    (28) expr -> expr . MODULO expr
    (29) expr -> expr . LT expr
    (30) expr -> expr . LE expr
    (31) expr -> expr . GT expr
    (32) expr -> expr . GE expr
    (33) expr -> expr . EQ expr
    (34) expr -> expr . NE expr
    (35) expr -> expr . AND expr
    (36) expr -> expr . OR expr

    SEMI            reduce using rule 26 (expr -> expr TIMES expr .)
    PLUS            reduce using rule 26 (expr -> expr TIMES expr .)
    MINUS           reduce using rule 26 (expr -> expr TIMES expr .)
    TIMES           reduce using rule 26 (expr -> expr TIMES expr .)
    DIVIDE          reduce using rule 26 (expr -> expr TIMES expr .)
    MODULO          reduce using rule 26 (expr -> expr TIMES expr .)
    RPAREN          reduce using rule 26 (expr -> expr TIMES expr .)
    LT              shift and go to state 42
    LE              shift and go to state 43
    GT              shift and go to state 44
    GE              shift and go to state 45
    EQ              shift and go to state 46
    NE              shift and go to state 47
    AND             shift and go to state 48
    OR              shift and go to state 49

  ! LT              [ reduce using rule 26 (expr -> expr TIMES expr .) ]
  ! LE              [ reduce using rule 26 (expr -> expr TIMES expr .) ]
  ! GT              [ reduce using rule 26 (expr -> expr TIMES expr .) ]
  ! GE              [ reduce using rule 26 (expr -> expr TIMES expr .) ]
  ! EQ              [ reduce using rule 26 (expr -> expr TIMES expr .) ]
  ! NE              [ reduce using rule 26 (expr -> expr TIMES expr .) ]
  ! AND             [ reduce using rule 26 (expr -> expr TIMES expr .) ]
  ! OR              [ reduce using rule 26 (expr -> expr TIMES expr .) ]
  ! PLUS            [ shift and go to state 37 ]
  ! MINUS           [ shift and go to state 38 ]
  ! TIMES           [ shift and go to state 39 ]
  ! DIVIDE          [ shift and go to state 40 ]
  ! MODULO          [ shift and go to state 41 ]


state 59

    (27) expr -> expr DIVIDE expr .
    (24) expr -> expr . PLUS expr
    (25) expr -> expr . MINUS expr
    (26) expr -> expr . TIMES expr
    (27) expr -> expr . DIVIDE expr
    (28) expr -> expr . MODULO expr
    (29) expr -> expr . LT expr
    (30) expr -> expr . LE expr
    (31) expr -> expr . GT expr
    (32) expr -> expr . GE expr
    (33) expr -> expr . EQ expr
    (34) expr -> expr . NE expr
    (35) expr -> expr . AND expr
    (36) expr -> expr . OR expr

    SEMI            reduce using rule 27 (expr -> expr DIVIDE expr .)
    PLUS            reduce using rule 27 (expr -> expr DIVIDE expr .)
    MINUS           reduce using rule 27 (expr -> expr DIVIDE expr .)
    TIMES           reduce using rule 27 (expr -> expr DIVIDE expr .)
    DIVIDE          reduce using rule 27 (expr -> expr DIVIDE expr .)
    MODULO          reduce using rule 27 (expr -> expr DIVIDE expr .)
    RPAREN          reduce using rule 27 (expr -> expr DIVIDE expr .)
    LT              shift and go to state 42
    LE              shift and go to state 43
    GT              shift and go to state 44
    GE              shift and go to state 45
    EQ              shift and go to state 46
    NE              shift and go to state 47
    AND             shift and go to state 48
    OR              shift and go to state 49

  ! LT              [ reduce using rule 27 (expr -> expr DIVIDE expr .) ]
  ! LE              [ reduce using rule 27 (expr -> expr DIVIDE expr .) ]
  ! GT              [ reduce using rule 27 (expr -> expr DIVIDE expr .) ]
  ! GE              [ reduce using rule 27 (expr -> expr DIVIDE expr .) ]
  ! EQ              [ reduce using rule 27 (expr -> expr DIVIDE expr .) ]
  ! NE              [ reduce using rule 27 (expr -> expr DIVIDE expr .) ]
  ! AND             [ reduce using rule 27 (expr -> expr DIVIDE expr .) ]
  ! OR              [ reduce using rule 27 (expr -> expr DIVIDE expr .) ]
  ! PLUS            [ shift and go to state 37 ]
  ! MINUS           [ shift and go to state 38 ]
  ! TIMES           [ shift and go to state 39 ]
  ! DIVIDE          [ shift and go to state 40 ]
  ! MODULO          [ shift and go to state 41 ]


state 60

    (28) expr -> expr MODULO expr .
    (24) expr -> expr . PLUS expr
    (25) expr -> expr . MINUS expr
    (26) expr -> expr . TIMES expr
    (27) expr -> expr . DIVIDE expr
    (28) expr -> expr . MODULO expr
    (29) expr -> expr . LT expr
    (30) expr -> expr . LE expr
    (31) expr -> expr . GT expr
    (32) expr -> expr . GE expr
    (33) expr -> expr . EQ expr
    (34) expr -> expr . NE expr
    (35) expr -> expr . AND expr
    (36) expr -> expr . OR expr

    SEMI            reduce using rule 28 (expr -> expr MODULO expr .)
    PLUS            reduce using rule 28 (expr -> expr MODULO expr .)
    MINUS           reduce using rule 28 (expr -> expr MODULO expr .)
    TIMES           reduce using rule 28 (expr -> expr MODULO expr .)
    DIVIDE          reduce using rule 28 (expr -> expr MODULO expr .)
    MODULO          reduce using rule 28 (expr -> expr MODULO expr .)
    RPAREN          reduce using rule 28 (expr -> expr MODULO expr .)
    LT              shift and go to state 42
    LE              shift and go to state 43
    GT              shift and go to state 44
    GE              shift and go to state 45
    EQ              shift and go to state 46
    NE              shift and go to state 47
    AND             shift and go to state 48
    OR              shift and go to state 49

  ! LT              [ reduce using rule 28 (expr -> expr MODULO expr .) ]
  ! LE              [ reduce using rule 28 (expr -> expr MODULO expr .) ]
  ! GT              [ reduce using rule 28 (expr -> expr MODULO expr .) ]
  ! GE              [ reduce using rule 28 (expr -> expr MODULO expr .) ]
  ! EQ              [ reduce using rule 28 (expr -> expr MODULO expr .) ]
  ! NE              [ reduce using rule 28 (expr -> expr MODULO expr .) ]
  ! AND             [ reduce using rule 28 (expr -> expr MODULO expr .) ]
  ! OR              [ reduce using rule 28 (expr -> expr MODULO expr .) ]
  ! PLUS            [ shift and go to state 37 ]
  ! MINUS           [ shift and go to state 38 ]
  ! TIMES           [ shift and go to state 39 ]
  ! DIVIDE          [ shift and go to state 40 ]
  ! MODULO          [ shift and go to state 41 ]


state 61

    (29) expr -> expr LT expr .
    (24) expr -> expr . PLUS expr
    (25) expr -> expr . MINUS expr
    (26) expr -> expr . TIMES expr
    (27) expr -> expr . DIVIDE expr
    (28) expr -> expr . MODULO expr
    (29) expr -> expr . LT expr
    (30) expr -> expr . LE expr
    (31) expr -> expr . GT expr
    (32) expr -> expr . GE expr
    (33) expr -> expr . EQ expr
    (34) expr -> expr . NE expr
    (35) expr -> expr . AND expr
    (36) expr -> expr . OR expr

    SEMI            reduce using rule 29 (expr -> expr LT expr .)
    PLUS            reduce using rule 29 (expr -> expr LT expr .)
    MINUS           reduce using rule 29 (expr -> expr LT expr .)
    TIMES           reduce using rule 29 (expr -> expr LT expr .)
    DIVIDE          reduce using rule 29 (expr -> expr LT expr .)
    MODULO          reduce using rule 29 (expr -> expr LT expr .)
    LT              reduce using rule 29 (expr -> expr LT expr .)
    LE              reduce using rule 29 (expr -> expr LT expr .)
    GT              reduce using rule 29 (expr -> expr LT expr .)
    GE              reduce using rule 29 (expr -> expr LT expr .)
    EQ              reduce using rule 29 (expr -> expr LT expr .)
    NE              reduce using rule 29 (expr -> expr LT expr .)
    RPAREN          reduce using rule 29 (expr -> expr LT expr .)
    AND             shift and go to state 48
    OR              shift and go to state 49

  ! AND             [ reduce using rule 29 (expr -> expr LT expr .) ]
  ! OR              [ reduce using rule 29 (expr -> expr LT expr .) ]
  ! PLUS            [ shift and go to state 37 ]
  ! MINUS           [ shift and go to state 38 ]
  ! TIMES           [ shift and go to state 39 ]
  ! DIVIDE          [ shift and go to state 40 ]
  ! MODULO          [ shift and go to state 41 ]
  ! LT              [ shift and go to state 42 ]
  ! LE              [ shift and go to state 43 ]
  ! GT              [ shift and go to state 44 ]
  ! GE              [ shift and go to state 45 ]
  ! EQ              [ shift and go to state 46 ]
  ! NE              [ shift and go to state 47 ]


state 62

    (30) expr -> expr LE expr .
    (24) expr -> expr . PLUS expr
    (25) expr -> expr . MINUS expr
    (26) expr -> expr . TIMES expr
    (27) expr -> expr . DIVIDE expr
    (28) expr -> expr . MODULO expr
    (29) expr -> expr . LT expr
    (30) expr -> expr . LE expr
    (31) expr -> expr . GT expr
    (32) expr -> expr . GE expr
    (33) expr -> expr . EQ expr
    (34) expr -> expr . NE expr
    (35) expr -> expr . AND expr
    (36) expr -> expr . OR expr

    SEMI            reduce using rule 30 (expr -> expr LE expr .)
    PLUS            reduce using rule 30 (expr -> expr LE expr .)
    MINUS           reduce using rule 30 (expr -> expr LE expr .)
    TIMES           reduce using rule 30 (expr -> expr LE expr .)
    DIVIDE          reduce using rule 30 (expr -> expr LE expr .)
    MODULO          reduce using rule 30 (expr -> expr LE expr .)
    LT              reduce using rule 30 (expr -> expr LE expr .)
    LE              reduce using rule 30 (expr -> expr LE expr .)
    GT              reduce using rule 30 (expr -> expr LE expr .)
    GE              reduce using rule 30 (expr -> expr LE expr .)
    EQ              reduce using rule 30 (expr -> expr LE expr .)
    NE              reduce using rule 30 (expr -> expr LE expr .)
    RPAREN          reduce using rule 30 (expr -> expr LE expr .)
    AND             shift and go to state 48
    OR              shift and go to state 49

  ! AND             [ reduce using rule 30 (expr -> expr LE expr .) ]
  ! OR              [ reduce using rule 30 (expr -> expr LE expr .) ]
  ! PLUS            [ shift and go to state 37 ]
  ! MINUS           [ shift and go to state 38 ]
  ! TIMES           [ shift and go to state 39 ]
  ! DIVIDE          [ shift and go to state 40 ]
  ! MODULO          [ shift and go to state 41 ]
  ! LT              [ shift and go to state 42 ]
  ! LE              [ shift and go to state 43 ]
  ! GT              [ shift and go to state 44 ]
  ! GE              [ shift and go to state 45 ]
  ! EQ              [ shift and go to state 46 ]
  ! NE              [ shift and go to state 47 ]


state 63

    (31) expr -> expr GT expr .
    (24) expr -> expr . PLUS expr
    (25) expr -> expr . MINUS expr
    (26) expr -> expr . TIMES expr
    (27) expr -> expr . DIVIDE expr
    (28) expr -> expr . MODULO expr
    (29) expr -> expr . LT expr
    (30) expr -> expr . LE expr
    (31) expr -> expr . GT expr
    (32) expr -> expr . GE expr
    (33) expr -> expr . EQ expr
    (34) expr -> expr . NE expr
    (35) expr -> expr . AND expr
    (36) expr -> expr . OR expr

    SEMI            reduce using rule 31 (expr -> expr GT expr .)
    PLUS            reduce using rule 31 (expr -> expr GT expr .)
    MINUS           reduce using rule 31 (expr -> expr GT expr .)
    TIMES           reduce using rule 31 (expr -> expr GT expr .)
    DIVIDE          reduce using rule 31 (expr -> expr GT expr .)
    MODULO          reduce using rule 31 (expr -> expr GT expr .)
    LT              reduce using rule 31 (expr -> expr GT expr .)
    LE              reduce using rule 31 (expr -> expr GT expr .)
    GT              reduce using rule 31 (expr -> expr GT expr .)
    GE              reduce using rule 31 (expr -> expr GT expr .)
    EQ              reduce using rule 31 (expr -> expr GT expr .)
    NE              reduce using rule 31 (expr -> expr GT expr .)
    RPAREN          reduce using rule 31 (expr -> expr GT expr .)
    AND             shift and go to state 48
    OR              shift and go to state 49

  ! AND             [ reduce using rule 31 (expr -> expr GT expr .) ]
  ! OR              [ reduce using rule 31 (expr -> expr GT expr .) ]
  ! PLUS            [ shift and go to state 37 ]
  ! MINUS           [ shift and go to state 38 ]
  ! TIMES           [ shift and go to state 39 ]
  ! DIVIDE          [ shift and go to state 40 ]
  ! MODULO          [ shift and go to state 41 ]
  ! LT              [ shift and go to state 42 ]
  ! LE              [ shift and go to state 43 ]
  ! GT              [ shift and go to state 44 ]
  ! GE              [ shift and go to state 45 ]
  ! EQ              [ shift and go to state 46 ]
  ! NE              [ shift and go to state 47 ]


state 64

    (32) expr -> expr GE expr .
    (24) expr -> expr . PLUS expr
    (25) expr -> expr . MINUS expr
    (26) expr -> expr . TIMES expr
    (27) expr -> expr . DIVIDE expr
    (28) expr -> expr . MODULO expr
    (29) expr -> expr . LT expr
    (30) expr -> expr . LE expr
    (31) expr -> expr . GT expr
    (32) expr -> expr . GE expr
    (33) expr -> expr . EQ expr
    (34) expr -> expr . NE expr
    (35) expr -> expr . AND expr
    (36) expr -> expr . OR expr

    SEMI            reduce using rule 32 (expr -> expr GE expr .)
    PLUS            reduce using rule 32 (expr -> expr GE expr .)
    MINUS           reduce using rule 32 (expr -> expr GE expr .)
    TIMES           reduce using rule 32 (expr -> expr GE expr .)
    DIVIDE          reduce using rule 32 (expr -> expr GE expr .)
    MODULO          reduce using rule 32 (expr -> expr GE expr .)
    LT              reduce using rule 32 (expr -> expr GE expr .)
    LE              reduce using rule 32 (expr -> expr GE expr .)
    GT              reduce using rule 32 (expr -> expr GE expr .)
    GE              reduce using rule 32 (expr -> expr GE expr .)
    EQ              reduce using rule 32 (expr -> expr GE expr .)
    NE              reduce using rule 32 (expr -> expr GE expr .)
    RPAREN          reduce using rule 32 (expr -> expr GE expr .)
    AND             shift and go to state 48
    OR              shift and go to state 49

  ! AND             [ reduce using rule 32 (expr -> expr GE expr .) ]
  ! OR              [ reduce using rule 32 (expr -> expr GE expr .) ]
  ! PLUS            [ shift and go to state 37 ]
  ! MINUS           [ shift and go to state 38 ]
  ! TIMES           [ shift and go to state 39 ]
  ! DIVIDE          [ shift and go to state 40 ]
  ! MODULO          [ shift and go to state 41 ]
  ! LT              [ shift and go to state 42 ]
  ! LE              [ shift and go to state 43 ]
  ! GT              [ shift and go to state 44 ]
  ! GE              [ shift and go to state 45 ]
  ! EQ              [ shift and go to state 46 ]
  ! NE              [ shift and go to state 47 ]


state 65

    (33) expr -> expr EQ expr .
    (24) expr -> expr . PLUS expr
    (25) expr -> expr . MINUS expr
    (26) expr -> expr . TIMES expr
    (27) expr -> expr . DIVIDE expr
    (28) expr -> expr . MODULO expr
    (29) expr -> expr . LT expr
    (30) expr -> expr . LE expr
    (31) expr -> expr . GT expr
    (32) expr -> expr . GE expr
    (33) expr -> expr . EQ expr
    (34) expr -> expr . NE expr
    (35) expr -> expr . AND expr
    (36) expr -> expr . OR expr

    SEMI            reduce using rule 33 (expr -> expr EQ expr .)
    PLUS            reduce using rule 33 (expr -> expr EQ expr .)
    MINUS           reduce using rule 33 (expr -> expr EQ expr .)
    TIMES           reduce using rule 33 (expr -> expr EQ expr .)
    DIVIDE          reduce using rule 33 (expr -> expr EQ expr .)
    MODULO          reduce using rule 33 (expr -> expr EQ expr .)
    LT              reduce using rule 33 (expr -> expr EQ expr .)
    LE              reduce using rule 33 (expr -> expr EQ expr .)
    GT              reduce using rule 33 (expr -> expr EQ expr .)
    GE              reduce using rule 33 (expr -> expr EQ expr .)
    EQ              reduce using rule 33 (expr -> expr EQ expr .)
    NE              reduce using rule 33 (expr -> expr EQ expr .)
    RPAREN          reduce using rule 33 (expr -> expr EQ expr .)
    AND             shift and go to state 48
    OR              shift and go to state 49

  ! AND             [ reduce using rule 33 (expr -> expr EQ expr .) ]
  ! OR              [ reduce using rule 33 (expr -> expr EQ expr .) ]
  ! PLUS            [ shift and go to state 37 ]
  ! MINUS           [ shift and go to state 38 ]
  ! TIMES           [ shift and go to state 39 ]
  ! DIVIDE          [ shift and go to state 40 ]
  ! MODULO          [ shift and go to state 41 ]
  ! LT              [ shift and go to state 42 ]
  ! LE              [ shift and go to state 43 ]
  ! GT              [ shift and go to state 44 ]
  ! GE              [ shift and go to state 45 ]
  ! EQ              [ shift and go to state 46 ]
  ! NE              [ shift and go to state 47 ]


state 66

    (34) expr -> expr NE expr .
    (24) expr -> expr . PLUS expr
    (25) expr -> expr . MINUS expr
    (26) expr -> expr . TIMES expr
    (27) expr -> expr . DIVIDE expr
    (28) expr -> expr . MODULO expr
    (29) expr -> expr . LT expr
    (30) expr -> expr . LE expr
    (31) expr -> expr . GT expr
    (32) expr -> expr . GE expr
    (33) expr -> expr . EQ expr
    (34) expr -> expr . NE expr
    (35) expr -> expr . AND expr
    (36) expr -> expr . OR expr

    SEMI            reduce using rule 34 (expr -> expr NE expr .)
    PLUS            reduce using rule 34 (expr -> expr NE expr .)
    MINUS           reduce using rule 34 (expr -> expr NE expr .)
    TIMES           reduce using rule 34 (expr -> expr NE expr .)
    DIVIDE          reduce using rule 34 (expr -> expr NE expr .)
    MODULO          reduce using rule 34 (expr -> expr NE expr .)
    LT              reduce using rule 34 (expr -> expr NE expr .)
    LE              reduce using rule 34 (expr -> expr NE expr .)
    GT              reduce using rule 34 (expr -> expr NE expr .)
    GE              reduce using rule 34 (expr -> expr NE expr .)
    EQ              reduce using rule 34 (expr -> expr NE expr .)
    NE              reduce using rule 34 (expr -> expr NE expr .)
    RPAREN          reduce using rule 34 (expr -> expr NE expr .)
    AND             shift and go to state 48
    OR              shift and go to state 49

  ! AND             [ reduce using rule 34 (expr -> expr NE expr .) ]
  ! OR              [ reduce using rule 34 (expr -> expr NE expr .) ]
  ! PLUS            [ shift and go to state 37 ]
  ! MINUS           [ shift and go to state 38 ]
  ! TIMES           [ shift and go to state 39 ]
  ! DIVIDE          [ shift and go to state 40 ]
  ! MODULO          [ shift and go to state 41 ]
  ! LT              [ shift and go to state 42 ]
  ! LE              [ shift and go to state 43 ]
  ! GT              [ shift and go to state 44 ]
  ! GE              [ shift and go to state 45 ]
  ! EQ              [ shift and go to state 46 ]
  ! NE              [ shift and go to state 47 ]


state 67

    (35) expr -> expr AND expr .
    (24) expr -> expr . PLUS expr
    (25) expr -> expr . MINUS expr
    (26) expr -> expr . TIMES expr
    (27) expr -> expr . DIVIDE expr
    (28) expr -> expr . MODULO expr
    (29) expr -> expr . LT expr
    (30) expr -> expr . LE expr
    (31) expr -> expr . GT expr
    (32) expr -> expr . GE expr
    (33) expr -> expr . EQ expr
    (34) expr -> expr . NE expr
    (35) expr -> expr . AND expr
    (36) expr -> expr . OR expr

    SEMI            reduce using rule 35 (expr -> expr AND expr .)
    PLUS            reduce using rule 35 (expr -> expr AND expr .)
    MINUS           reduce using rule 35 (expr -> expr AND expr .)
    TIMES           reduce using rule 35 (expr -> expr AND expr .)
    DIVIDE          reduce using rule 35 (expr -> expr AND expr .)
    MODULO          reduce using rule 35 (expr -> expr AND expr .)
    LT              reduce using rule 35 (expr -> expr AND expr .)
    LE              reduce using rule 35 (expr -> expr AND expr .)
    GT              reduce using rule 35 (expr -> expr AND expr .)
    GE              reduce using rule 35 (expr -> expr AND expr .)
    EQ              reduce using rule 35 (expr -> expr AND expr .)
    NE              reduce using rule 35 (expr -> expr AND expr .)
    AND             reduce using rule 35 (expr -> expr AND expr .)
    OR              reduce using rule 35 (expr -> expr AND expr .)
    RPAREN          reduce using rule 35 (expr -> expr AND expr .)

  ! PLUS            [ shift and go to state 37 ]
  ! MINUS           [ shift and go to state 38 ]
  ! TIMES           [ shift and go to state 39 ]
  ! DIVIDE          [ shift and go to state 40 ]
  ! MODULO          [ shift and go to state 41 ]
  ! LT              [ shift and go to state 42 ]
  ! LE              [ shift and go to state 43 ]
  ! GT              [ shift and go to state 44 ]
  ! GE              [ shift and go to state 45 ]
  ! EQ              [ shift and go to state 46 ]
  ! NE              [ shift and go to state 47 ]
  ! AND             [ shift and go to state 48 ]
  ! OR              [ shift and go to state 49 ]


state 68

    (36) expr -> expr OR expr .
    (24) expr -> expr . PLUS expr
    (25) expr -> expr . MINUS expr
    (26) expr -> expr . TIMES expr
    (27) expr -> expr . DIVIDE expr
    (28) expr -> expr . MODULO expr
    (29) expr -> expr . LT expr
    (30) expr -> expr . LE expr
    (31) expr -> expr . GT expr
    (32) expr -> expr . GE expr
    (33) expr -> expr . EQ expr
    (34) expr -> expr . NE expr
    (35) expr -> expr . AND expr
    (36) expr -> expr . OR expr

    SEMI            reduce using rule 36 (expr -> expr OR expr .)
    PLUS            reduce using rule 36 (expr -> expr OR expr .)
    MINUS           reduce using rule 36 (expr -> expr OR expr .)
    TIMES           reduce using rule 36 (expr -> expr OR expr .)
    DIVIDE          reduce using rule 36 (expr -> expr OR expr .)
    MODULO          reduce using rule 36 (expr -> expr OR expr .)
    LT              reduce using rule 36 (expr -> expr OR expr .)
    LE              reduce using rule 36 (expr -> expr OR expr .)
    GT              reduce using rule 36 (expr -> expr OR expr .)
    GE              reduce using rule 36 (expr -> expr OR expr .)
    EQ              reduce using rule 36 (expr -> expr OR expr .)
    NE              reduce using rule 36 (expr -> expr OR expr .)
    AND             reduce using rule 36 (expr -> expr OR expr .)
    OR              reduce using rule 36 (expr -> expr OR expr .)
    RPAREN          reduce using rule 36 (expr -> expr OR expr .)

  ! PLUS            [ shift and go to state 37 ]
  ! MINUS           [ shift and go to state 38 ]
  ! TIMES           [ shift and go to state 39 ]
  ! DIVIDE          [ shift and go to state 40 ]
  ! MODULO          [ shift and go to state 41 ]
  ! LT              [ shift and go to state 42 ]
  ! LE              [ shift and go to state 43 ]
  ! GT              [ shift and go to state 44 ]
  ! GE              [ shift and go to state 45 ]
  ! EQ              [ shift and go to state 46 ]
  ! NE              [ shift and go to state 47 ]
  ! AND             [ shift and go to state 48 ]
  ! OR              [ shift and go to state 49 ]


state 69

    (17) if_stmt -> IF LPAREN expr . RPAREN compound_stmt
    (18) if_stmt -> IF LPAREN expr . RPAREN compound_stmt ELSE compound_stmt
    (24) expr -> expr . PLUS expr
    (25) expr -> expr . MINUS expr
    (26) expr -> expr . TIMES expr
    (27) expr -> expr . DIVIDE expr
    (28) expr -> expr . MODULO expr
    (29) expr -> expr . LT expr
    (30) expr -> expr . LE expr
    (31) expr -> expr . GT expr
    (32) expr -> expr . GE expr
    (33) expr -> expr . EQ expr
    (34) expr -> expr . NE expr
    (35) expr -> expr . AND expr
    (36) expr -> expr . OR expr

    RPAREN          shift and go to state 74
    PLUS            shift and go to state 37
    MINUS           shift and go to state 38
    TIMES           shift and go to state 39
    DIVIDE          shift and go to state 40
    MODULO          shift and go to state 41
    LT              shift and go to state 42
    LE              shift and go to state 43
    GT              shift and go to state 44
    GE              shift and go to state 45
    EQ              shift and go to state 46
    NE              shift and go to state 47
    AND             shift and go to state 48
    OR              shift and go to state 49


state 70

    (38) expr -> LPAREN expr RPAREN .

    SEMI            reduce using rule 38 (expr -> LPAREN expr RPAREN .)
    PLUS            reduce using rule 38 (expr -> LPAREN expr RPAREN .)
    MINUS           reduce using rule 38 (expr -> LPAREN expr RPAREN .)
    TIMES           reduce using rule 38 (expr -> LPAREN expr RPAREN .)
    DIVIDE          reduce using rule 38 (expr -> LPAREN expr RPAREN .)
    MODULO          reduce using rule 38 (expr -> LPAREN expr RPAREN .)
    LT              reduce using rule 38 (expr -> LPAREN expr RPAREN .)
    LE              reduce using rule 38 (expr -> LPAREN expr RPAREN .)
    GT              reduce using rule 38 (expr -> LPAREN expr RPAREN .)
    GE              reduce using rule 38 (expr -> LPAREN expr RPAREN .)
    EQ              reduce using rule 38 (expr -> LPAREN expr RPAREN .)
    NE              reduce using rule 38 (expr -> LPAREN expr RPAREN .)
    AND             reduce using rule 38 (expr -> LPAREN expr RPAREN .)
    OR              reduce using rule 38 (expr -> LPAREN expr RPAREN .)
    RPAREN          reduce using rule 38 (expr -> LPAREN expr RPAREN .)


state 71

    (19) return_stmt -> RETURN expr SEMI .

    IF              reduce using rule 19 (return_stmt -> RETURN expr SEMI .)
    RETURN          reduce using rule 19 (return_stmt -> RETURN expr SEMI .)
    NUMBER          reduce using rule 19 (return_stmt -> RETURN expr SEMI .)
    NOT             reduce using rule 19 (return_stmt -> RETURN expr SEMI .)
    LPAREN          reduce using rule 19 (return_stmt -> RETURN expr SEMI .)
    INT             reduce using rule 19 (return_stmt -> RETURN expr SEMI .)
    VOID            reduce using rule 19 (return_stmt -> RETURN expr SEMI .)
    CHAR            reduce using rule 19 (return_stmt -> RETURN expr SEMI .)
    ID              reduce using rule 19 (return_stmt -> RETURN expr SEMI .)
    RBRACE          reduce using rule 19 (return_stmt -> RETURN expr SEMI .)


state 72

    (20) var_decl -> type ID SEMI .

    IF              reduce using rule 20 (var_decl -> type ID SEMI .)
    RETURN          reduce using rule 20 (var_decl -> type ID SEMI .)
    NUMBER          reduce using rule 20 (var_decl -> type ID SEMI .)
    NOT             reduce using rule 20 (var_decl -> type ID SEMI .)
    LPAREN          reduce using rule 20 (var_decl -> type ID SEMI .)
    INT             reduce using rule 20 (var_decl -> type ID SEMI .)
    VOID            reduce using rule 20 (var_decl -> type ID SEMI .)
    CHAR            reduce using rule 20 (var_decl -> type ID SEMI .)
    ID              reduce using rule 20 (var_decl -> type ID SEMI .)
    RBRACE          reduce using rule 20 (var_decl -> type ID SEMI .)


state 73

    (21) expr -> var ASSIGN expr .
    (24) expr -> expr . PLUS expr
    (25) expr -> expr . MINUS expr
    (26) expr -> expr . TIMES expr
    (27) expr -> expr . DIVIDE expr
    (28) expr -> expr . MODULO expr
    (29) expr -> expr . LT expr
    (30) expr -> expr . LE expr
    (31) expr -> expr . GT expr
    (32) expr -> expr . GE expr
    (33) expr -> expr . EQ expr
    (34) expr -> expr . NE expr
    (35) expr -> expr . AND expr
    (36) expr -> expr . OR expr

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULO resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMI            reduce using rule 21 (expr -> var ASSIGN expr .)
    RPAREN          reduce using rule 21 (expr -> var ASSIGN expr .)
    PLUS            shift and go to state 37
    MINUS           shift and go to state 38
    TIMES           shift and go to state 39
    DIVIDE          shift and go to state 40
    MODULO          shift and go to state 41
    LT              shift and go to state 42
    LE              shift and go to state 43
    GT              shift and go to state 44
    GE              shift and go to state 45
    EQ              shift and go to state 46
    NE              shift and go to state 47
    AND             shift and go to state 48
    OR              shift and go to state 49

  ! PLUS            [ reduce using rule 21 (expr -> var ASSIGN expr .) ]
  ! MINUS           [ reduce using rule 21 (expr -> var ASSIGN expr .) ]
  ! TIMES           [ reduce using rule 21 (expr -> var ASSIGN expr .) ]
  ! DIVIDE          [ reduce using rule 21 (expr -> var ASSIGN expr .) ]
  ! MODULO          [ reduce using rule 21 (expr -> var ASSIGN expr .) ]
  ! LT              [ reduce using rule 21 (expr -> var ASSIGN expr .) ]
  ! LE              [ reduce using rule 21 (expr -> var ASSIGN expr .) ]
  ! GT              [ reduce using rule 21 (expr -> var ASSIGN expr .) ]
  ! GE              [ reduce using rule 21 (expr -> var ASSIGN expr .) ]
  ! EQ              [ reduce using rule 21 (expr -> var ASSIGN expr .) ]
  ! NE              [ reduce using rule 21 (expr -> var ASSIGN expr .) ]
  ! AND             [ reduce using rule 21 (expr -> var ASSIGN expr .) ]
  ! OR              [ reduce using rule 21 (expr -> var ASSIGN expr .) ]


state 74

    (17) if_stmt -> IF LPAREN expr RPAREN . compound_stmt
    (18) if_stmt -> IF LPAREN expr RPAREN . compound_stmt ELSE compound_stmt
    (9) compound_stmt -> . LBRACE stmt_list RBRACE

    LBRACE          shift and go to state 16

    compound_stmt                  shift and go to state 75

state 75

    (17) if_stmt -> IF LPAREN expr RPAREN compound_stmt .
    (18) if_stmt -> IF LPAREN expr RPAREN compound_stmt . ELSE compound_stmt

    IF              reduce using rule 17 (if_stmt -> IF LPAREN expr RPAREN compound_stmt .)
    RETURN          reduce using rule 17 (if_stmt -> IF LPAREN expr RPAREN compound_stmt .)
    NUMBER          reduce using rule 17 (if_stmt -> IF LPAREN expr RPAREN compound_stmt .)
    NOT             reduce using rule 17 (if_stmt -> IF LPAREN expr RPAREN compound_stmt .)
    LPAREN          reduce using rule 17 (if_stmt -> IF LPAREN expr RPAREN compound_stmt .)
    INT             reduce using rule 17 (if_stmt -> IF LPAREN expr RPAREN compound_stmt .)
    VOID            reduce using rule 17 (if_stmt -> IF LPAREN expr RPAREN compound_stmt .)
    CHAR            reduce using rule 17 (if_stmt -> IF LPAREN expr RPAREN compound_stmt .)
    ID              reduce using rule 17 (if_stmt -> IF LPAREN expr RPAREN compound_stmt .)
    RBRACE          reduce using rule 17 (if_stmt -> IF LPAREN expr RPAREN compound_stmt .)
    ELSE            shift and go to state 76


state 76

    (18) if_stmt -> IF LPAREN expr RPAREN compound_stmt ELSE . compound_stmt
    (9) compound_stmt -> . LBRACE stmt_list RBRACE

    LBRACE          shift and go to state 16

    compound_stmt                  shift and go to state 77

state 77

    (18) if_stmt -> IF LPAREN expr RPAREN compound_stmt ELSE compound_stmt .

    IF              reduce using rule 18 (if_stmt -> IF LPAREN expr RPAREN compound_stmt ELSE compound_stmt .)
    RETURN          reduce using rule 18 (if_stmt -> IF LPAREN expr RPAREN compound_stmt ELSE compound_stmt .)
    NUMBER          reduce using rule 18 (if_stmt -> IF LPAREN expr RPAREN compound_stmt ELSE compound_stmt .)
    NOT             reduce using rule 18 (if_stmt -> IF LPAREN expr RPAREN compound_stmt ELSE compound_stmt .)
    LPAREN          reduce using rule 18 (if_stmt -> IF LPAREN expr RPAREN compound_stmt ELSE compound_stmt .)
    INT             reduce using rule 18 (if_stmt -> IF LPAREN expr RPAREN compound_stmt ELSE compound_stmt .)
    VOID            reduce using rule 18 (if_stmt -> IF LPAREN expr RPAREN compound_stmt ELSE compound_stmt .)
    CHAR            reduce using rule 18 (if_stmt -> IF LPAREN expr RPAREN compound_stmt ELSE compound_stmt .)
    ID              reduce using rule 18 (if_stmt -> IF LPAREN expr RPAREN compound_stmt ELSE compound_stmt .)
    RBRACE          reduce using rule 18 (if_stmt -> IF LPAREN expr RPAREN compound_stmt ELSE compound_stmt .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for PLUS in state 73 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 73 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 73 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 73 resolved as shift
WARNING: shift/reduce conflict for MODULO in state 73 resolved as shift
WARNING: shift/reduce conflict for LT in state 73 resolved as shift
WARNING: shift/reduce conflict for LE in state 73 resolved as shift
WARNING: shift/reduce conflict for GT in state 73 resolved as shift
WARNING: shift/reduce conflict for GE in state 73 resolved as shift
WARNING: shift/reduce conflict for EQ in state 73 resolved as shift
WARNING: shift/reduce conflict for NE in state 73 resolved as shift
WARNING: shift/reduce conflict for AND in state 73 resolved as shift
WARNING: shift/reduce conflict for OR in state 73 resolved as shift
